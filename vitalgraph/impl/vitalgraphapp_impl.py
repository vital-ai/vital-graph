import os
import json
from datetime import datetime, timedelta
from typing import Dict, List, Optional, Any
from pathlib import Path
from fastapi import FastAPI, Request, Response, HTTPException, status, Depends, Form, Body
from fastapi.responses import HTMLResponse, RedirectResponse, JSONResponse, FileResponse
from fastapi.staticfiles import StaticFiles
from fastapi.middleware.cors import CORSMiddleware
from fastapi.security import OAuth2PasswordBearer, OAuth2PasswordRequestForm
from starlette.middleware.sessions import SessionMiddleware
from pydantic import BaseModel, Field
import uvicorn

# Import VitalGraph configuration loader
from vitalgraph.config.config_loader import get_config, ConfigurationError
from vitalgraph.api.vitalgraph_api import VitalGraphAPI
from vitalgraph.auth.vitalgraph_auth import VitalGraphAuth
from vitalgraph.impl.vitalgraph_impl import VitalGraphImpl


# Pydantic Models for API Documentation
class Space(BaseModel):
    """Space model for VitalGraph database.
    
    Represents a graph space that contains RDF data and knowledge graphs.
    Spaces provide logical separation of data within the VitalGraph system.
    """
    id: Optional[int] = Field(
        None, 
        description="Unique space identifier (auto-generated by server)",
        example=1
    )
    tenant: Optional[str] = Field(
        None, 
        description="Tenant identifier for multi-tenant deployments (optional)",
        example="acme_corp"
    )
    space: str = Field(
        ..., 
        description="Space identifier - unique name for the space (required)",
        example="knowledge_base"
    )
    space_name: str = Field(
        ..., 
        description="Human-readable display name for the space (required)",
        example="Knowledge Base"
    )
    space_description: Optional[str] = Field(
        None, 
        description="Detailed description of the space purpose and contents (optional)",
        example="Primary knowledge base containing product information and documentation"
    )
    update_time: Optional[str] = Field(
        None, 
        description="ISO timestamp of last modification (auto-generated by server)",
        example="2025-01-22T00:36:33.214308"
    )
    
    class Config:
        json_schema_extra = {
            "example": {
                "id": 1,
                "tenant": "acme_corp",
                "space": "knowledge_base",
                "space_name": "Knowledge Base",
                "space_description": "Primary knowledge base containing product information and documentation",
                "update_time": "2025-01-22T00:36:33.214308"
            }
        }

class User(BaseModel):
    """User model for VitalGraph database.
    
    Represents a user account with authentication credentials and profile information.
    Users can access and manage spaces within their authorized tenant scope.
    """
    id: Optional[int] = Field(
        None, 
        description="Unique user identifier (auto-generated by server)",
        example=1
    )
    tenant: Optional[str] = Field(
        None, 
        description="Tenant identifier for multi-tenant deployments (optional)",
        example="acme_corp"
    )
    username: str = Field(
        ..., 
        description="Unique username for authentication (required)",
        example="john_doe"
    )
    password: str = Field(
        ..., 
        description="User password (required for creation, included in API responses)",
        example="secure_password123"
    )
    email: str = Field(
        ..., 
        description="User email address for notifications and recovery (required)",
        example="john.doe@acme-corp.com"
    )
    update_time: Optional[str] = Field(
        None, 
        description="ISO timestamp of last modification (auto-generated by server)",
        example="2025-01-22T00:36:33.214308"
    )
    
    class Config:
        json_schema_extra = {
            "example": {
                "id": 1,
                "tenant": "acme_corp",
                "username": "john_doe",
                "password": "secure_password123",
                "email": "john.doe@acme-corp.com",
                "update_time": "2025-01-22T00:36:33.214308"
            }
        }

class DeleteResponse(BaseModel):
    """Model for deletion confirmation response.
    
    Returned when a space or user is successfully deleted from the system.
    Provides confirmation message and the ID of the deleted item.
    """
    message: str = Field(
        ..., 
        description="Confirmation message indicating successful deletion",
        example="space deleted successfully"
    )
    id: int = Field(
        ..., 
        description="ID of the deleted item for reference",
        example=1
    )
    
    class Config:
        json_schema_extra = {
            "example": {
                "message": "space deleted successfully",
                "id": 1
            }
        }


class VitalGraphAppImpl:
    def __init__(self, app: FastAPI, config=None):
        self.app = app
        self.config = config
        
        # Set app mode - 'production' serves frontend, 'development' is API only
        self.app_mode = os.getenv("APP_MODE", "development").lower()
        
        # Initialize VitalGraphImpl which handles configuration and database initialization
        self.vital_graph_impl = VitalGraphImpl(config=self.config)
        
        # Get database implementation from VitalGraphImpl
        self.db_impl = self.vital_graph_impl.get_db_impl()
        
        # Update config reference in case it was loaded by VitalGraphImpl
        self.config = self.vital_graph_impl.get_config()
        
        # Initialize authentication
        self.auth = VitalGraphAuth()
        
        # Initialize VitalGraph API with auth handler and database implementation
        self.api = VitalGraphAPI(self.auth, db_impl=self.db_impl)
        
        # Add dependency for getting current user (needed before route setup)
        self.get_current_user = self.auth.create_get_current_user_dependency()
        
        # Setup middleware, static files, startup events, and routes
        self._setup_middleware()
        self._setup_static_files()
        self._setup_startup_events()
        self._setup_routes()

    def _setup_middleware(self):
        """Setup CORS and session middleware"""
        # Add CORS middleware
        self.app.add_middleware(
            CORSMiddleware,
            allow_origins=["*"],  # Configure appropriately for production
            allow_credentials=True,
            allow_methods=["*"],
            allow_headers=["*"],
        )
        
        # Add session middleware for authentication
        self.app.add_middleware(
            SessionMiddleware,
            secret_key=os.getenv("SESSION_SECRET_KEY", "your-secret-key-here"),
            max_age=86400  # 24 hours
        )

    def _setup_static_files(self):
        """Mount React frontend build files only in production"""
        if self.app_mode == "production":
            # Mount static files from React build
            project_root = Path(__file__).parent.parent.parent
            static_dir = project_root / "vitalgraph" / "api" / "frontend" / "dist"
            
            if static_dir.exists():
                self.app.mount("/static", StaticFiles(directory=str(static_dir)), name="static")
            else:
                print(f"Warning: Static files directory not found at {static_dir}")

    def _setup_startup_events(self):
        """Setup FastAPI startup events"""
        @self.app.on_event("startup")
        async def startup_event():
            """Connect to database on server startup"""
            if self.db_impl:
                try:
                    await self.db_impl.connect()
                    print("✅ Connected to database successfully")
                except Exception as e:
                    print(f"❌ Failed to connect to database: {e}")

    def _setup_routes(self):
        """Setup all application routes"""
        # Authentication wrapper functions
        async def logout_wrapper(request: Request, current_user: Dict = Depends(self.get_current_user)):
            return await self.logout(request, current_user)
        
        # Space CRUD wrapper functions
        async def list_spaces_wrapper(current_user: Dict = Depends(self.get_current_user)) -> List[Space]:
            return await self.api.list_spaces(current_user)
        
        async def add_space_wrapper(space_data: Space, current_user: Dict = Depends(self.get_current_user)) -> Space:
            return await self.api.add_space(space_data.dict(), current_user)
        
        async def get_space_wrapper(space_id: int, current_user: Dict = Depends(self.get_current_user)) -> Space:
            return await self.api.get_space(space_id, current_user)
        
        async def update_space_wrapper(space_id: int, space_data: Space, current_user: Dict = Depends(self.get_current_user)) -> Space:
            return await self.api.update_space(space_id, space_data.dict(), current_user)
        
        async def delete_space_wrapper(space_id: int, current_user: Dict = Depends(self.get_current_user)) -> DeleteResponse:
            return await self.api.delete_space(space_id, current_user)
        
        async def filter_spaces_wrapper(name_filter: str, current_user: Dict = Depends(self.get_current_user)) -> List[Space]:
            return await self.api.filter_spaces_by_name(name_filter, current_user)
        
        # User CRUD wrapper functions
        async def list_users_wrapper(current_user: Dict = Depends(self.get_current_user)) -> List[User]:
            return await self.api.list_users(current_user)
        
        async def add_user_wrapper(user_data: User, current_user: Dict = Depends(self.get_current_user)) -> User:
            return await self.api.add_user(user_data.dict(), current_user)
        
        async def get_user_wrapper(user_id: int, current_user: Dict = Depends(self.get_current_user)) -> User:
            return await self.api.get_user(user_id, current_user)
        
        async def update_user_wrapper(user_id: int, user_data: User, current_user: Dict = Depends(self.get_current_user)) -> User:
            return await self.api.update_user(user_id, user_data.dict(), current_user)
        
        async def delete_user_wrapper(user_id: int, current_user: Dict = Depends(self.get_current_user)) -> DeleteResponse:
            return await self.api.delete_user(user_id, current_user)
        
        async def filter_users_wrapper(name_filter: str, current_user: Dict = Depends(self.get_current_user)) -> List[User]:
            return await self.api.filter_users_by_name(name_filter, current_user)
        
        # SPARQL wrapper function
        async def sparql_endpoint_wrapper(
            query: str = Body(..., embed=True),
            current_user: Dict = Depends(self.get_current_user)
        ):
            return await self.sparql_endpoint(query, current_user)

        # Authentication routes
        self.app.post(
            "/api/login",
            tags=["Authentication"],
            summary="User Login",
            description="Authenticate user and generate access token for API access"
        )(self.login)
        self.app.post(
            "/api/logout",
            tags=["Authentication"],
            summary="User Logout",
            description="Invalidate current session and log out user"
        )(logout_wrapper)

        # Space CRUD routes
        self.app.get(
            "/api/spaces",
            tags=["Spaces"],
            summary="List Spaces",
            description="Get a list of all accessible graph spaces for the authenticated user",
            response_model=List[Space]
        )(list_spaces_wrapper)
        self.app.post(
            "/api/spaces",
            tags=["Spaces"],
            summary="Create Space",
            description="Create a new graph space for storing RDF data and knowledge graphs",
            response_model=Space
        )(add_space_wrapper)
        self.app.get(
            "/api/spaces/{space_id}",
            tags=["Spaces"],
            summary="Get Space",
            description="Retrieve detailed information about a specific graph space by ID",
            response_model=Space
        )(get_space_wrapper)
        self.app.put(
            "/api/spaces/{space_id}",
            tags=["Spaces"],
            summary="Update Space",
            description="Update an existing graph space (requires complete space object)",
            response_model=Space
        )(update_space_wrapper)
        self.app.delete(
            "/api/spaces/{space_id}",
            tags=["Spaces"],
            summary="Delete Space",
            description="Permanently delete a graph space and all associated RDF data",
            response_model=DeleteResponse
        )(delete_space_wrapper)
        self.app.get(
            "/api/spaces/filter/{name_filter}",
            tags=["Spaces"],
            summary="Filter Spaces by Name",
            description="Search for spaces whose names contain the specified filter text",
            response_model=List[Space]
        )(filter_spaces_wrapper)

        # User CRUD routes
        self.app.get(
            "/api/users",
            tags=["Users"],
            summary="List Users",
            description="Get a list of all accessible user accounts for the authenticated user",
            response_model=List[User]
        )(list_users_wrapper)
        self.app.post(
            "/api/users",
            tags=["Users"],
            summary="Create User",
            description="Create a new user account with authentication credentials",
            response_model=User
        )(add_user_wrapper)
        self.app.get(
            "/api/users/{user_id}",
            tags=["Users"],
            summary="Get User",
            description="Retrieve detailed information about a specific user account by ID",
            response_model=User
        )(get_user_wrapper)
        self.app.put(
            "/api/users/{user_id}",
            tags=["Users"],
            summary="Update User",
            description="Update an existing user account (requires complete user object)",
            response_model=User
        )(update_user_wrapper)
        self.app.delete(
            "/api/users/{user_id}",
            tags=["Users"],
            summary="Delete User",
            description="Permanently delete a user account and revoke access",
            response_model=DeleteResponse
        )(delete_user_wrapper)
        self.app.get(
            "/api/users/filter/{name_filter}",
            tags=["Users"],
            summary="Filter Users by Name",
            description="Search for users whose usernames contain the specified filter text",
            response_model=List[User]
        )(filter_users_wrapper)

        # SPARQL endpoint
        self.app.post(
            "/api/graphs/sparql",
            tags=["SPARQL"],
            summary="Execute SPARQL Query",
            description="Execute a SPARQL query against the knowledge graph and return results"
        )(sparql_endpoint_wrapper)

        # System routes
        self.app.get(
            "/health",
            tags=["System"],
            summary="Health Check",
            description="Check the health status of the VitalGraph server and database connection"
        )(self.health)
        
        # Frontend serving routes
        if self.app_mode == "production":
            self.app.get("/", response_class=HTMLResponse)(self.serve_frontend)
            self.app.get("/{path:path}")(self.catch_all)
        else:
            self.app.get("/")(self.api_root)
    


    async def login(self, form_data: OAuth2PasswordRequestForm = Depends()):
        """Login endpoint - delegates to API class"""
        return await self.api.login(form_data)

    async def logout(self, request: Request, current_user: Dict):
        """Logout endpoint - delegates to API class"""
        return await self.api.logout(request, current_user)

    async def list_spaces(self, current_user: Dict):
        """Get list of spaces for the authenticated user"""
        return await self.api.list_spaces(current_user)

    async def sparql_endpoint(
        self,
        query: str,
        current_user: Dict
    ):
        """Execute a SPARQL query"""
        return await self.api.execute_sparql_query(query, current_user)

    async def health(self):
        """Health check endpoint - delegates to API class"""
        return await self.api.health()
    
    async def serve_frontend(self):
        """Serve the built React app's index.html"""
        project_root = Path(__file__).parent.parent.parent
        index_path = project_root / "vitalgraph" / "api" / "frontend" / "dist" / "index.html"
        if index_path.exists():
            with open(index_path) as f:
                return HTMLResponse(content=f.read())
        # Fallback to API docs if index.html doesn't exist
        return RedirectResponse(url="/docs")
    
    async def api_root(self):
        """Development mode root endpoint"""
        return {
            "message": "VitalGraph API Server",
            "documentation": "/docs",
            "alternative_docs": "/redoc"
        }
    
    async def catch_all(self, path: str):
        """Catch-all route for client-side routing - only in production"""
        project_root = Path(__file__).parent.parent.parent
        
        # First, try to serve static files from the dist directory (SVGs, favicon, etc.)
        static_file_path = project_root / "vitalgraph" / "api" / "frontend" / "dist" / path
        if static_file_path.exists() and static_file_path.is_file():
            return FileResponse(static_file_path)
        
        # Only catch routes that don't start with /api or /static for SPA routing
        if path.startswith("api/") or path.startswith("static/") or path.startswith("docs") or path == "openapi.json":
            raise HTTPException(status_code=404, detail="Not found")
        
        # Return the index.html for client-side routing
        index_path = project_root / "vitalgraph" / "api" / "frontend" / "dist" / "index.html"
        if index_path.exists():
            with open(index_path) as f:
                return HTMLResponse(content=f.read())
        return RedirectResponse(url="/docs")
